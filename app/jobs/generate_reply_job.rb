class GenerateReplyJob < ApplicationJob
  queue_as :default

  def perform(conversation, user_message)
    # Don't generate replies if character is away (this shouldn't happen, but safety check)
    if conversation.character_away?
      Rails.logger.info "Character is away, skipping reply generation for conversation #{conversation.id}"
      return
    end

    conversation.update(generating_reply: true)

    # Check if this is the character "returning" from being away
    # In this case, we need to process all queued user messages since the character went away
    messages_to_process = if character_should_return?(conversation)
        get_queued_user_messages_since_character_away(conversation)
      else
        [user_message]
      end

    # Evolve the scene prompt based on all messages to process
    prompt_service = AiPromptGenerationService.new(conversation)
    current_prompt = prompt_service.get_current_scene_prompt
    first_prompt = current_prompt

    # # Process all queued messages to evolve the prompt
    # messages_to_process.each do |msg|
    #   current_prompt = prompt_service.evolve_scene_prompt(current_prompt, msg.content, msg.created_at)
    #   Rails.logger.info "Scene prompt evolved after processing message: #{msg.content[0..50]}..."
    # end

    # Generate chat response asynchronously
    GenerateChatResponseJob.perform_later(conversation, user_message)
  end

  private

  # Check if the character should return from being away
  def character_should_return?(conversation)
    # This method is called when processing a new user message
    # The character should "return" if there are queued user messages waiting
    conversation.character_away? && has_queued_user_messages?(conversation)
  end

  # Check if there are user messages queued while character was away
  def has_queued_user_messages?(conversation)
    return false unless conversation.character_away?

    # Find the last autogenerated assistant message (the one that triggered the character going away)
    autogen_message = conversation.messages.where(role: "assistant")
      .where("metadata LIKE ?", "%auto_generated%")
      .order(:created_at).last

    return false unless autogen_message

    # Check if there are user messages after the autogenerated message
    conversation.messages.where(role: "user")
      .where("created_at > ?", autogen_message.created_at)
      .exists?
  end

  # Get all user messages that were sent while character was away
  def get_queued_user_messages_since_character_away(conversation)
    # Find the last autogenerated assistant message to determine when character went away
    autogen_message = conversation.messages.where(role: "assistant")
      .where("metadata LIKE ?", "%auto_generated%")
      .order(:created_at).last

    if autogen_message
      # Get all user messages since the character's autogenerated message
      conversation.messages.where(role: "user")
        .where("created_at > ?", autogen_message.created_at)
        .order(:created_at)
    else
      # Fallback: just return the current message if no autogenerated message found
      [conversation.messages.where(role: "user").order(:created_at).last].compact
    end
  end
end
